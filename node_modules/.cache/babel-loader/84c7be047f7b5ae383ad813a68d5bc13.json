{"ast":null,"code":"import { createContext, useRef, useState, useLayoutEffect, createElement, useContext, useEffect, useMemo, useCallback, Children, isValidElement, Fragment } from 'react';\nimport { createMemoryHistory, Action, parsePath } from 'history';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction invariant(cond, message) {\n  if (!cond) throw new Error(message);\n}\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message); // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nconst alreadyWarned = {};\n\nfunction warningOnce(key, cond, message) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    process.env.NODE_ENV !== \"production\" ? warning(false, message) : void 0;\n  }\n}\n\nconst NavigatorContext = /*#__PURE__*/createContext(null);\nconst LocationContext = /*#__PURE__*/createContext({\n  static: false\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  LocationContext.displayName = \"Location\";\n}\n\nconst RouteContext = /*#__PURE__*/createContext({\n  outlet: null,\n  params: {},\n  pathname: \"\",\n  basename: \"\",\n  route: null\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  RouteContext.displayName = \"Route\";\n}\n/**\r\n * A <Router> that stores all entries in memory.\r\n *\r\n * @see https://reactrouter.com/api/MemoryRouter\r\n */\n\n\nfunction MemoryRouter(_ref) {\n  let {\n    children,\n    initialEntries,\n    initialIndex\n  } = _ref;\n  let historyRef = useRef();\n\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({\n      initialEntries,\n      initialIndex\n    });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = useState({\n    action: history.action,\n    location: history.location\n  });\n  useLayoutEffect(() => history.listen(setState), [history]);\n  return /*#__PURE__*/createElement(Router, {\n    children: children,\n    action: state.action,\n    location: state.location,\n    navigator: history\n  });\n}\n/**\r\n * Changes the current location.\r\n *\r\n * Note: This API is mostly useful in React.Component subclasses that are not\r\n * able to use hooks. In functional components, we recommend you use the\r\n * `useNavigate` hook instead.\r\n *\r\n * @see https://reactrouter.com/api/Navigate\r\n */\n\n\nfunction Navigate(_ref2) {\n  let {\n    to,\n    replace,\n    state\n  } = _ref2;\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of\n  // the router loaded. We can help them understand how to avoid that.\n  \"<Navigate> may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  process.env.NODE_ENV !== \"production\" ? warning(!useContext(LocationContext).static, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : void 0;\n  let navigate = useNavigate();\n  useEffect(() => {\n    navigate(to, {\n      replace,\n      state\n    });\n  });\n  return null;\n}\n/**\r\n * Renders the child route's element, if there is one.\r\n *\r\n * @see https://reactrouter.com/api/Outlet\r\n */\n\n\nfunction Outlet(_props) {\n  return useOutlet();\n}\n/**\r\n * Declares an element that should be rendered at a certain URL path.\r\n *\r\n * @see https://reactrouter.com/api/Route\r\n */\n\n\nfunction Route(_props) {\n  process.env.NODE_ENV !== \"production\" ? invariant(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\") : invariant(false);\n}\n/**\r\n * Provides location context for the rest of the app.\r\n *\r\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\r\n * router that is more specific to your environment such as a <BrowserRouter>\r\n * in web browsers or a <StaticRouter> for server rendering.\r\n *\r\n * @see https://reactrouter.com/api/Router\r\n */\n\n\nfunction Router(_ref3) {\n  let {\n    children = null,\n    action = Action.Pop,\n    location,\n    navigator,\n    static: staticProp = false\n  } = _ref3;\n  !!useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"You cannot render a <Router> inside another <Router>.\" + \" You never need more than one.\") : invariant(false) : void 0;\n  return /*#__PURE__*/createElement(NavigatorContext.Provider, {\n    value: navigator\n  }, /*#__PURE__*/createElement(LocationContext.Provider, {\n    children: children,\n    value: {\n      action,\n      location,\n      static: staticProp\n    }\n  }));\n}\n/**\r\n * A container for a nested tree of <Route> elements that renders the branch\r\n * that best matches the current location.\r\n *\r\n * @see https://reactrouter.com/api/Routes\r\n */\n\n\nfunction Routes(_ref4) {\n  let {\n    basename = \"\",\n    children,\n    location\n  } = _ref4;\n  let routes = createRoutesFromChildren(children);\n  return useRoutes(routes, {\n    location,\n    basename\n  });\n} ///////////////////////////////////////////////////////////////////////////////\n// HOOKS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * Blocks all navigation attempts. This is useful for preventing the page from\r\n * changing until some condition is met, like saving form data.\r\n *\r\n * @see https://reactrouter.com/api/useBlocker\r\n */\n\n\nfunction useBlocker(blocker, when) {\n  if (when === void 0) {\n    when = true;\n  }\n\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useBlocker() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  let navigator = useContext(NavigatorContext);\n  useEffect(() => {\n    if (!when) return;\n    let unblock = navigator.block(tx => {\n      let autoUnblockingTx = _extends({}, tx, {\n        retry() {\n          // Automatically unblock the transition so it can play all the way\n          // through before retrying it. TODO: Figure out how to re-enable\n          // this block if the transition is cancelled for some reason.\n          unblock();\n          tx.retry();\n        }\n\n      });\n\n      blocker(autoUnblockingTx);\n    });\n    return unblock;\n  }, [navigator, blocker, when]);\n}\n/**\r\n * Returns the full href for the given \"to\" value. This is useful for building\r\n * custom links that are also accessible and preserve right-click behavior.\r\n *\r\n * @see https://reactrouter.com/api/useHref\r\n */\n\n\nfunction useHref(to) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useHref() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  let navigator = useContext(NavigatorContext);\n  let path = useResolvedPath(to);\n  return navigator.createHref(path);\n}\n/**\r\n * Returns true if this component is a descendant of a <Router>.\r\n *\r\n * @see https://reactrouter.com/api/useInRouterContext\r\n */\n\n\nfunction useInRouterContext() {\n  return useContext(LocationContext).location != null;\n}\n/**\r\n * Returns the current location object, which represents the current URL in web\r\n * browsers.\r\n *\r\n * Note: If you're using this it may mean you're doing some of your own\r\n * \"routing\" in your app, and we'd like to know what your use case is. We may\r\n * be able to provide something higher-level to better suit your needs.\r\n *\r\n * @see https://reactrouter.com/api/useLocation\r\n */\n\n\nfunction useLocation() {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useLocation() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  return useContext(LocationContext).location;\n}\n/**\r\n * Returns true if the URL for the given \"to\" value matches the current URL.\r\n * This is useful for components that need to know \"active\" state, e.g.\r\n * <NavLink>.\r\n *\r\n * @see https://reactrouter.com/api/useMatch\r\n */\n\n\nfunction useMatch(pattern) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useMatch() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  let location = useLocation();\n  return matchPath(pattern, location.pathname);\n}\n/**\r\n * Returns an imperative method for changing the location. Used by <Link>s, but\r\n * may also be used by other elements to change the location.\r\n *\r\n * @see https://reactrouter.com/api/useNavigate\r\n */\n\n\nfunction useNavigate() {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useNavigate() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  let navigator = useContext(NavigatorContext);\n  let {\n    basename,\n    pathname: parentRoutePathname\n  } = useContext(RouteContext);\n  let {\n    pathname: currentLocationPathname\n  } = useLocation();\n  let activeRef = useRef(false);\n  useEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = useCallback(function (to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (activeRef.current) {\n      if (typeof to === \"number\") {\n        navigator.go(to);\n      } else {\n        let toPathname = // Empty strings should be treated the same as / paths\n        to === \"\" || to.pathname === \"\" ? \"/\" : typeof to === \"string\" ? parsePath(to).pathname : to.pathname;\n        let path = resolvePath(to, // If a pathname is explicitly provided in `to`, it should be\n        // relative to the parent route context. This is explained in `Note\n        // on `<Link to>` values` in our migration guide from v5 as a means\n        // of disambiguation between `to` values that begin with `/` and\n        // those that do not. However, this is problematic for `to` values\n        // that do not provide a pathname. `to` can simply be a search or\n        // hash string, in which case we should assume that the navigation\n        // is relative to the current location's pathname and *not* the\n        // pathname from the parent route.\n        toPathname ? parentRoutePathname : currentLocationPathname, basename);\n        (!!options.replace ? navigator.replace : navigator.push)(path, options.state);\n      }\n    } else {\n      process.env.NODE_ENV !== \"production\" ? warning(false, \"You should call navigate() in a useEffect, not when \" + \"your component is first rendered.\") : void 0;\n    }\n  }, [basename, navigator, parentRoutePathname, currentLocationPathname]);\n  return navigate;\n}\n/**\r\n * Returns the element for the child route at this level of the route\r\n * hierarchy. Used internally by <Outlet> to render child routes.\r\n *\r\n * @see https://reactrouter.com/api/useOutlet\r\n */\n\n\nfunction useOutlet() {\n  return useContext(RouteContext).outlet;\n}\n/**\r\n * Returns an object of key/value pairs of the dynamic params from the current\r\n * URL that were matched by the route path.\r\n *\r\n * @see https://reactrouter.com/api/useParams\r\n */\n\n\nfunction useParams() {\n  return useContext(RouteContext).params;\n}\n/**\r\n * Resolves the pathname of the given `to` value against the current location.\r\n *\r\n * @see https://reactrouter.com/api/useResolvedPath\r\n */\n\n\nfunction useResolvedPath(to) {\n  let {\n    pathname,\n    basename\n  } = useContext(RouteContext);\n  return useMemo(() => resolvePath(to, pathname, basename), [to, pathname, basename]);\n}\n/**\r\n * Returns the element of the route that matched the current location, prepared\r\n * with the correct context to render the remainder of the route tree. Route\r\n * elements in the tree must render an <Outlet> to render their child route's\r\n * element.\r\n *\r\n * @see https://reactrouter.com/api/useRoutes\r\n */\n\n\nfunction useRoutes(routes, _temp) {\n  let {\n    basename = \"\",\n    location: locationArg\n  } = _temp === void 0 ? {} : _temp;\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useRoutes() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  let {\n    route: parentRoute,\n    pathname: parentPathname,\n    params: parentParams\n  } = useContext(RouteContext);\n\n  if (process.env.NODE_ENV !== \"production\") {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since we\n    // cannot even give the warning unless they land at the parent route.\n    //\n    // Example:\n    //\n    // <Routes>\n    //   {/* This route path MUST end with /* because otherwise\n    //       it will never match /blog/post/123 */}\n    //   <Route path=\"blog\" element={<Blog />} />\n    //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n    // </Routes>\n    //\n    // function Blog() {\n    //   return (\n    //     <Routes>\n    //       <Route path=\"post/:id\" element={<Post />} />\n    //     </Routes>\n    //   );\n    // }\n    let parentPath = parentRoute && parentRoute.path || \"\";\n    warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes`) at \" + (\"\\\"\" + parentPathname + \"\\\" (under <Route path=\\\"\" + parentPath + \"\\\">) but the \") + \"parent route path has no trailing \\\"*\\\". This means if you navigate \" + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + (\"Please change the parent <Route path=\\\"\" + parentPath + \"\\\"> to <Route \") + (\"path=\\\"\" + parentPath + \"/*\\\">.\"));\n  }\n\n  let locationFromContext = useLocation();\n  let location = locationArg !== null && locationArg !== void 0 ? locationArg : locationFromContext;\n  let basenameForMatching = basename ? joinPaths([parentPathname, basename]) : parentPathname;\n  let matches = useMemo(() => matchRoutes(routes, location, basenameForMatching), [routes, location, basenameForMatching]);\n\n  if (!matches) {\n    // TODO: Warn about nothing matching, suggest using a catch-all route.\n    return null;\n  } // Otherwise render an element.\n\n\n  let params = Object.assign({}, parentParams);\n  let element = matches.reduceRight((outlet, match) => {\n    Object.assign(params, match.params);\n    return /*#__PURE__*/createElement(RouteContext.Provider, {\n      children: match.route.element || /*#__PURE__*/createElement(Outlet, null),\n      value: {\n        outlet,\n        params: params,\n        pathname: joinPaths([basenameForMatching, match.pathname]),\n        basename,\n        route: match.route\n      }\n    });\n  }, null);\n  return element;\n} ///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * Creates a route config from a React \"children\" object, which is usually\r\n * either a `<Route>` element or an array of them. Used internally by\r\n * `<Routes>` to create a route config from its children.\r\n *\r\n * @see https://reactrouter.com/api/createRoutesFromChildren\r\n */\n\n\nfunction createRoutesFromChildren(children) {\n  let routes = [];\n  Children.forEach(children, element => {\n    if (! /*#__PURE__*/isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n\n    if (element.type === Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(routes, createRoutesFromChildren(element.props.children));\n      return;\n    }\n\n    let route = {\n      path: element.props.path,\n      caseSensitive: element.props.caseSensitive,\n      index: element.props.index,\n      element: element.props.element\n    };\n\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children);\n    }\n\n    routes.push(route);\n  });\n  return routes;\n}\n/**\r\n * Returns a path with params interpolated.\r\n *\r\n * @see https://reactrouter.com/api/generatePath\r\n */\n\n\nfunction generatePath(path, params) {\n  if (params === void 0) {\n    params = {};\n  }\n\n  return path.replace(/:(\\w+)/g, (_, key) => {\n    !(params[key] != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Missing \\\":\" + key + \"\\\" param\") : invariant(false) : void 0;\n    return params[key];\n  }).replace(/\\/*\\*$/, _ => params[\"*\"] == null ? \"\" : params[\"*\"].replace(/^\\/*/, \"/\"));\n}\n/**\r\n * Matches the given routes to a location and returns the match data.\r\n *\r\n * @see https://reactrouter.com/api/matchRoutes\r\n */\n\n\nfunction matchRoutes(routes, location, basename) {\n  if (basename === void 0) {\n    basename = \"\";\n  }\n\n  if (typeof location === \"string\") {\n    location = parsePath(location);\n  }\n\n  let pathname = location.pathname || \"/\";\n\n  if (basename) {\n    let base = basename.replace(/^\\/*/, \"/\").replace(/\\/+$/, \"\"); // Basename should be case-insensitive\n    // https://github.com/remix-run/react-router/issues/7997#issuecomment-911916907\n\n    if (!pathname.toLowerCase().startsWith(base.toLowerCase())) {\n      return null;\n    }\n\n    pathname = pathname.slice(base.length) || \"/\";\n  }\n\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n  let matches = null;\n\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch(branches[i], pathname, routes);\n  }\n\n  return matches;\n}\n\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\n  if (branches === void 0) {\n    branches = [];\n  }\n\n  if (parentsMeta === void 0) {\n    parentsMeta = [];\n  }\n\n  if (parentPath === void 0) {\n    parentPath = \"\";\n  }\n\n  routes.forEach((route, index) => {\n    let meta = {\n      relativePath: route.path || \"\",\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index\n    };\n\n    if (meta.relativePath.startsWith(\"/\")) {\n      !meta.relativePath.startsWith(parentPath) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Absolute route path \\\"\" + meta.relativePath + \"\\\" nested under path \" + (\"\\\"\" + parentPath + \"\\\" is not valid. An absolute child route path \") + \"must start with the combined path of all its parent routes.\") : invariant(false) : void 0;\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta); // Add the children before adding this route to the array so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n\n    if (route.children && route.children.length > 0) {\n      !(route.index !== true) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Index routes must not have child routes. Please remove \" + (\"all child routes from route path \\\"\" + path + \"\\\".\")) : invariant(false) : void 0;\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n\n    branches.push({\n      path,\n      routesMeta\n    });\n  });\n  return branches;\n}\n\nfunction rankRouteBranches(branches) {\n  let pathScores = {};\n  let pathIndexes = {};\n  branches.forEach(_ref5 => {\n    let {\n      path,\n      routesMeta\n    } = _ref5;\n    pathScores[path] = computeScore(path);\n    pathIndexes[path] = routesMeta.map(meta => meta.childrenIndex);\n  });\n  branches.sort((a, b) => {\n    let aScore = pathScores[a.path];\n    let bScore = pathScores[b.path];\n    return aScore !== bScore ? bScore - aScore // Higher score first\n    : compareIndexes(pathIndexes[a.path], pathIndexes[b.path]);\n  });\n}\n\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\n\nconst isSplat = s => s === \"*\";\n\nfunction computeScore(path) {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n\n  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\n}\n\nfunction compareIndexes(a, b) {\n  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n  return siblings ? // If two routes are siblings, we should try to match the earlier sibling\n  // first. This allows people to have fine-grained control over the matching\n  // behavior by simply putting routes with identical paths in the order they\n  // want them tried.\n  a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n  // so they sort equally.\n  0;\n}\n\nfunction matchRouteBranch(branch, pathname, originalRoutes) {\n  let matchedPathname = \"/\";\n  let matchedParams = {};\n  let {\n    routesMeta\n  } = branch;\n  let routes = originalRoutes;\n  let matches = [];\n\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath({\n      path: meta.relativePath,\n      caseSensitive: meta.caseSensitive,\n      end: i === routesMeta.length - 1\n    }, remainingPathname);\n    if (!match) return null;\n    matchedParams = _extends({}, matchedParams, match.params);\n    matchedPathname = joinPaths([matchedPathname, match.pathname]);\n    let route = routes[meta.childrenIndex];\n    matches.push({\n      params: matchedParams,\n      pathname: matchedPathname,\n      route\n    });\n    routes = route.children;\n  }\n\n  return matches;\n}\n/**\r\n * Performs pattern matching on a URL pathname and returns information about\r\n * the match.\r\n *\r\n * @see https://reactrouter.com/api/matchPath\r\n */\n\n\nfunction matchPath(pattern, pathname) {\n  if (typeof pattern === \"string\") {\n    pattern = {\n      path: pattern,\n      caseSensitive: false,\n      end: true\n    };\n  }\n\n  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n  let match = pathname.match(matcher);\n  if (!match) return null;\n  let matchedPathname = match[1];\n  let values = match.slice(2);\n  let params = paramNames.reduce((memo, paramName, index) => {\n    memo[paramName] = safelyDecodeURIComponent(values[index] || \"\", paramName);\n    return memo;\n  }, {});\n  return {\n    params,\n    pathname: matchedPathname,\n    pattern\n  };\n}\n\nfunction compilePath(path, caseSensitive, end) {\n  if (caseSensitive === void 0) {\n    caseSensitive = false;\n  }\n\n  if (end === void 0) {\n    end = true;\n  }\n\n  let keys = [];\n  let source = \"^(\" + path.replace(/^\\/*/, \"/\") // Make sure it has a leading /\n  .replace(/\\/?\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n  .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n  .replace(/:(\\w+)/g, (_, key) => {\n    keys.push(key);\n    return \"([^\\\\/]+)\";\n  }) + \")\";\n\n  if (path.endsWith(\"*\")) {\n    if (path.endsWith(\"/*\")) {\n      source += \"(?:\\\\/(.+)|\\\\/?)\"; // Don't include the / in params['*']\n    } else {\n      source += \"(.*)\";\n    }\n\n    keys.push(\"*\");\n  } else if (end) {\n    source += \"\\\\/?\";\n  }\n\n  if (end) source += \"$\";\n  let flags = caseSensitive ? undefined : \"i\";\n  let matcher = new RegExp(source, flags);\n  return [matcher, keys];\n}\n\nfunction safelyDecodeURIComponent(value, paramName) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    process.env.NODE_ENV !== \"production\" ? warning(false, \"The value for the URL param \\\"\" + paramName + \"\\\" will not be decoded because\" + (\" the string \\\"\" + value + \"\\\" is a malformed URL segment. This is probably\") + (\" due to a bad percent encoding (\" + error + \").\")) : void 0;\n    return value;\n  }\n}\n/**\r\n * Returns a resolved path object relative to the given pathname.\r\n *\r\n * @see https://reactrouter.com/api/resolvePath\r\n */\n\n\nfunction resolvePath(to, fromPathname, basename) {\n  if (fromPathname === void 0) {\n    fromPathname = \"/\";\n  }\n\n  if (basename === void 0) {\n    basename = \"\";\n  }\n\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\"\n  } = typeof to === \"string\" ? parsePath(to) : to;\n  let pathname = toPathname ? resolvePathname(toPathname, toPathname.startsWith(\"/\") ? basename ? normalizeSlashes(\"/\" + basename) : \"/\" : fromPathname) : fromPathname;\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash)\n  };\n}\n\nconst trimTrailingSlashes = path => path.replace(/\\/+$/, \"\");\n\nconst normalizeSlashes = path => path.replace(/\\/\\/+/g, \"/\");\n\nconst joinPaths = paths => normalizeSlashes(paths.join(\"/\"));\n\nconst splitPath = path => normalizeSlashes(path).split(\"/\");\n\nconst normalizeSearch = search => !search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\n\nconst normalizeHash = hash => !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n\nfunction resolvePathname(toPathname, fromPathname) {\n  let segments = splitPath(trimTrailingSlashes(fromPathname));\n  let relativeSegments = splitPath(toPathname);\n  relativeSegments.forEach(segment => {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n  return segments.length > 1 ? joinPaths(segments) : \"/\";\n} ///////////////////////////////////////////////////////////////////////////////\n\n\nexport { MemoryRouter, Navigate, Outlet, Route, Router, Routes, LocationContext as UNSAFE_LocationContext, NavigatorContext as UNSAFE_NavigatorContext, RouteContext as UNSAFE_RouteContext, createRoutesFromChildren, generatePath, matchPath, matchRoutes, resolvePath, useBlocker, useHref, useInRouterContext, useLocation, useMatch, useNavigate, useOutlet, useParams, useResolvedPath, useRoutes };","map":{"version":3,"sources":["../../packages/react-router/index.tsx"],"names":["React.useContext","React.useRef"],"mappings":"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","sourcesContent":["import { createContext, useRef, useState, useLayoutEffect, createElement, useContext, useEffect, useMemo, useCallback, Children, isValidElement, Fragment } from 'react';\r\nimport { createMemoryHistory, Action, parsePath } from 'history';\r\n\r\nfunction _extends() {\r\n  _extends = Object.assign || function (target) {\r\n    for (var i = 1; i < arguments.length; i++) {\r\n      var source = arguments[i];\r\n\r\n      for (var key in source) {\r\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n          target[key] = source[key];\r\n        }\r\n      }\r\n    }\r\n\r\n    return target;\r\n  };\r\n\r\n  return _extends.apply(this, arguments);\r\n}\r\n\r\nfunction invariant(cond, message) {\r\n  if (!cond) throw new Error(message);\r\n}\r\n\r\nfunction warning(cond, message) {\r\n  if (!cond) {\r\n    // eslint-disable-next-line no-console\r\n    if (typeof console !== \"undefined\") console.warn(message);\r\n\r\n    try {\r\n      // Welcome to debugging React Router!\r\n      //\r\n      // This error is thrown as a convenience so you can more easily\r\n      // find the source for a warning that appears in the console by\r\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\r\n      throw new Error(message); // eslint-disable-next-line no-empty\r\n    } catch (e) {}\r\n  }\r\n}\r\n\r\nconst alreadyWarned = {};\r\n\r\nfunction warningOnce(key, cond, message) {\r\n  if (!cond && !alreadyWarned[key]) {\r\n    alreadyWarned[key] = true;\r\n    process.env.NODE_ENV !== \"production\" ? warning(false, message) : void 0;\r\n  }\r\n}\r\n\r\nconst NavigatorContext = /*#__PURE__*/createContext(null);\r\nconst LocationContext = /*#__PURE__*/createContext({\r\n  static: false\r\n});\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  LocationContext.displayName = \"Location\";\r\n}\r\n\r\nconst RouteContext = /*#__PURE__*/createContext({\r\n  outlet: null,\r\n  params: {},\r\n  pathname: \"\",\r\n  basename: \"\",\r\n  route: null\r\n});\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  RouteContext.displayName = \"Route\";\r\n}\r\n/**\r\n * A <Router> that stores all entries in memory.\r\n *\r\n * @see https://reactrouter.com/api/MemoryRouter\r\n */\r\n\r\n\r\nfunction MemoryRouter(_ref) {\r\n  let {\r\n    children,\r\n    initialEntries,\r\n    initialIndex\r\n  } = _ref;\r\n  let historyRef = useRef();\r\n\r\n  if (historyRef.current == null) {\r\n    historyRef.current = createMemoryHistory({\r\n      initialEntries,\r\n      initialIndex\r\n    });\r\n  }\r\n\r\n  let history = historyRef.current;\r\n  let [state, setState] = useState({\r\n    action: history.action,\r\n    location: history.location\r\n  });\r\n  useLayoutEffect(() => history.listen(setState), [history]);\r\n  return /*#__PURE__*/createElement(Router, {\r\n    children: children,\r\n    action: state.action,\r\n    location: state.location,\r\n    navigator: history\r\n  });\r\n}\r\n/**\r\n * Changes the current location.\r\n *\r\n * Note: This API is mostly useful in React.Component subclasses that are not\r\n * able to use hooks. In functional components, we recommend you use the\r\n * `useNavigate` hook instead.\r\n *\r\n * @see https://reactrouter.com/api/Navigate\r\n */\r\n\r\nfunction Navigate(_ref2) {\r\n  let {\r\n    to,\r\n    replace,\r\n    state\r\n  } = _ref2;\r\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of\r\n  // the router loaded. We can help them understand how to avoid that.\r\n  \"<Navigate> may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\r\n  process.env.NODE_ENV !== \"production\" ? warning(!useContext(LocationContext).static, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : void 0;\r\n  let navigate = useNavigate();\r\n  useEffect(() => {\r\n    navigate(to, {\r\n      replace,\r\n      state\r\n    });\r\n  });\r\n  return null;\r\n}\r\n/**\r\n * Renders the child route's element, if there is one.\r\n *\r\n * @see https://reactrouter.com/api/Outlet\r\n */\r\n\r\nfunction Outlet(_props) {\r\n  return useOutlet();\r\n}\r\n/**\r\n * Declares an element that should be rendered at a certain URL path.\r\n *\r\n * @see https://reactrouter.com/api/Route\r\n */\r\n\r\nfunction Route(_props) {\r\n   process.env.NODE_ENV !== \"production\" ? invariant(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\") : invariant(false) ;\r\n}\r\n/**\r\n * Provides location context for the rest of the app.\r\n *\r\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\r\n * router that is more specific to your environment such as a <BrowserRouter>\r\n * in web browsers or a <StaticRouter> for server rendering.\r\n *\r\n * @see https://reactrouter.com/api/Router\r\n */\r\n\r\nfunction Router(_ref3) {\r\n  let {\r\n    children = null,\r\n    action = Action.Pop,\r\n    location,\r\n    navigator,\r\n    static: staticProp = false\r\n  } = _ref3;\r\n  !!useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"You cannot render a <Router> inside another <Router>.\" + \" You never need more than one.\") : invariant(false) : void 0;\r\n  return /*#__PURE__*/createElement(NavigatorContext.Provider, {\r\n    value: navigator\r\n  }, /*#__PURE__*/createElement(LocationContext.Provider, {\r\n    children: children,\r\n    value: {\r\n      action,\r\n      location,\r\n      static: staticProp\r\n    }\r\n  }));\r\n}\r\n/**\r\n * A container for a nested tree of <Route> elements that renders the branch\r\n * that best matches the current location.\r\n *\r\n * @see https://reactrouter.com/api/Routes\r\n */\r\n\r\nfunction Routes(_ref4) {\r\n  let {\r\n    basename = \"\",\r\n    children,\r\n    location\r\n  } = _ref4;\r\n  let routes = createRoutesFromChildren(children);\r\n  return useRoutes(routes, {\r\n    location,\r\n    basename\r\n  });\r\n} ///////////////////////////////////////////////////////////////////////////////\r\n// HOOKS\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/**\r\n * Blocks all navigation attempts. This is useful for preventing the page from\r\n * changing until some condition is met, like saving form data.\r\n *\r\n * @see https://reactrouter.com/api/useBlocker\r\n */\r\n\r\nfunction useBlocker(blocker, when) {\r\n  if (when === void 0) {\r\n    when = true;\r\n  }\r\n\r\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\r\n  // router loaded. We can help them understand how to avoid that.\r\n  \"useBlocker() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\r\n  let navigator = useContext(NavigatorContext);\r\n  useEffect(() => {\r\n    if (!when) return;\r\n    let unblock = navigator.block(tx => {\r\n      let autoUnblockingTx = _extends({}, tx, {\r\n        retry() {\r\n          // Automatically unblock the transition so it can play all the way\r\n          // through before retrying it. TODO: Figure out how to re-enable\r\n          // this block if the transition is cancelled for some reason.\r\n          unblock();\r\n          tx.retry();\r\n        }\r\n\r\n      });\r\n\r\n      blocker(autoUnblockingTx);\r\n    });\r\n    return unblock;\r\n  }, [navigator, blocker, when]);\r\n}\r\n/**\r\n * Returns the full href for the given \"to\" value. This is useful for building\r\n * custom links that are also accessible and preserve right-click behavior.\r\n *\r\n * @see https://reactrouter.com/api/useHref\r\n */\r\n\r\nfunction useHref(to) {\r\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\r\n  // router loaded. We can help them understand how to avoid that.\r\n  \"useHref() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\r\n  let navigator = useContext(NavigatorContext);\r\n  let path = useResolvedPath(to);\r\n  return navigator.createHref(path);\r\n}\r\n/**\r\n * Returns true if this component is a descendant of a <Router>.\r\n *\r\n * @see https://reactrouter.com/api/useInRouterContext\r\n */\r\n\r\nfunction useInRouterContext() {\r\n  return useContext(LocationContext).location != null;\r\n}\r\n/**\r\n * Returns the current location object, which represents the current URL in web\r\n * browsers.\r\n *\r\n * Note: If you're using this it may mean you're doing some of your own\r\n * \"routing\" in your app, and we'd like to know what your use case is. We may\r\n * be able to provide something higher-level to better suit your needs.\r\n *\r\n * @see https://reactrouter.com/api/useLocation\r\n */\r\n\r\nfunction useLocation() {\r\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\r\n  // router loaded. We can help them understand how to avoid that.\r\n  \"useLocation() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\r\n  return useContext(LocationContext).location;\r\n}\r\n/**\r\n * Returns true if the URL for the given \"to\" value matches the current URL.\r\n * This is useful for components that need to know \"active\" state, e.g.\r\n * <NavLink>.\r\n *\r\n * @see https://reactrouter.com/api/useMatch\r\n */\r\n\r\nfunction useMatch(pattern) {\r\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\r\n  // router loaded. We can help them understand how to avoid that.\r\n  \"useMatch() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\r\n  let location = useLocation();\r\n  return matchPath(pattern, location.pathname);\r\n}\r\n/**\r\n * Returns an imperative method for changing the location. Used by <Link>s, but\r\n * may also be used by other elements to change the location.\r\n *\r\n * @see https://reactrouter.com/api/useNavigate\r\n */\r\n\r\nfunction useNavigate() {\r\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\r\n  // router loaded. We can help them understand how to avoid that.\r\n  \"useNavigate() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\r\n  let navigator = useContext(NavigatorContext);\r\n  let {\r\n    basename,\r\n    pathname: parentRoutePathname\r\n  } = useContext(RouteContext);\r\n  let {\r\n    pathname: currentLocationPathname\r\n  } = useLocation();\r\n  let activeRef = useRef(false);\r\n  useEffect(() => {\r\n    activeRef.current = true;\r\n  });\r\n  let navigate = useCallback(function (to, options) {\r\n    if (options === void 0) {\r\n      options = {};\r\n    }\r\n\r\n    if (activeRef.current) {\r\n      if (typeof to === \"number\") {\r\n        navigator.go(to);\r\n      } else {\r\n        let toPathname = // Empty strings should be treated the same as / paths\r\n        to === \"\" || to.pathname === \"\" ? \"/\" : typeof to === \"string\" ? parsePath(to).pathname : to.pathname;\r\n        let path = resolvePath(to, // If a pathname is explicitly provided in `to`, it should be\r\n        // relative to the parent route context. This is explained in `Note\r\n        // on `<Link to>` values` in our migration guide from v5 as a means\r\n        // of disambiguation between `to` values that begin with `/` and\r\n        // those that do not. However, this is problematic for `to` values\r\n        // that do not provide a pathname. `to` can simply be a search or\r\n        // hash string, in which case we should assume that the navigation\r\n        // is relative to the current location's pathname and *not* the\r\n        // pathname from the parent route.\r\n        toPathname ? parentRoutePathname : currentLocationPathname, basename);\r\n        (!!options.replace ? navigator.replace : navigator.push)(path, options.state);\r\n      }\r\n    } else {\r\n      process.env.NODE_ENV !== \"production\" ? warning(false, \"You should call navigate() in a useEffect, not when \" + \"your component is first rendered.\") : void 0;\r\n    }\r\n  }, [basename, navigator, parentRoutePathname, currentLocationPathname]);\r\n  return navigate;\r\n}\r\n/**\r\n * Returns the element for the child route at this level of the route\r\n * hierarchy. Used internally by <Outlet> to render child routes.\r\n *\r\n * @see https://reactrouter.com/api/useOutlet\r\n */\r\n\r\nfunction useOutlet() {\r\n  return useContext(RouteContext).outlet;\r\n}\r\n/**\r\n * Returns an object of key/value pairs of the dynamic params from the current\r\n * URL that were matched by the route path.\r\n *\r\n * @see https://reactrouter.com/api/useParams\r\n */\r\n\r\nfunction useParams() {\r\n  return useContext(RouteContext).params;\r\n}\r\n/**\r\n * Resolves the pathname of the given `to` value against the current location.\r\n *\r\n * @see https://reactrouter.com/api/useResolvedPath\r\n */\r\n\r\nfunction useResolvedPath(to) {\r\n  let {\r\n    pathname,\r\n    basename\r\n  } = useContext(RouteContext);\r\n  return useMemo(() => resolvePath(to, pathname, basename), [to, pathname, basename]);\r\n}\r\n/**\r\n * Returns the element of the route that matched the current location, prepared\r\n * with the correct context to render the remainder of the route tree. Route\r\n * elements in the tree must render an <Outlet> to render their child route's\r\n * element.\r\n *\r\n * @see https://reactrouter.com/api/useRoutes\r\n */\r\n\r\nfunction useRoutes(routes, _temp) {\r\n  let {\r\n    basename = \"\",\r\n    location: locationArg\r\n  } = _temp === void 0 ? {} : _temp;\r\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\r\n  // router loaded. We can help them understand how to avoid that.\r\n  \"useRoutes() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\r\n  let {\r\n    route: parentRoute,\r\n    pathname: parentPathname,\r\n    params: parentParams\r\n  } = useContext(RouteContext);\r\n\r\n  if (process.env.NODE_ENV !== \"production\") {\r\n    // You won't get a warning about 2 different <Routes> under a <Route>\r\n    // without a trailing *, but this is a best-effort warning anyway since we\r\n    // cannot even give the warning unless they land at the parent route.\r\n    //\r\n    // Example:\r\n    //\r\n    // <Routes>\r\n    //   {/* This route path MUST end with /* because otherwise\r\n    //       it will never match /blog/post/123 */}\r\n    //   <Route path=\"blog\" element={<Blog />} />\r\n    //   <Route path=\"blog/feed\" element={<BlogFeed />} />\r\n    // </Routes>\r\n    //\r\n    // function Blog() {\r\n    //   return (\r\n    //     <Routes>\r\n    //       <Route path=\"post/:id\" element={<Post />} />\r\n    //     </Routes>\r\n    //   );\r\n    // }\r\n    let parentPath = parentRoute && parentRoute.path || \"\";\r\n    warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes`) at \" + (\"\\\"\" + parentPathname + \"\\\" (under <Route path=\\\"\" + parentPath + \"\\\">) but the \") + \"parent route path has no trailing \\\"*\\\". This means if you navigate \" + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + (\"Please change the parent <Route path=\\\"\" + parentPath + \"\\\"> to <Route \") + (\"path=\\\"\" + parentPath + \"/*\\\">.\"));\r\n  }\r\n\r\n  let locationFromContext = useLocation();\r\n  let location = locationArg !== null && locationArg !== void 0 ? locationArg : locationFromContext;\r\n  let basenameForMatching = basename ? joinPaths([parentPathname, basename]) : parentPathname;\r\n  let matches = useMemo(() => matchRoutes(routes, location, basenameForMatching), [routes, location, basenameForMatching]);\r\n\r\n  if (!matches) {\r\n    // TODO: Warn about nothing matching, suggest using a catch-all route.\r\n    return null;\r\n  } // Otherwise render an element.\r\n\r\n\r\n  let params = Object.assign({}, parentParams);\r\n  let element = matches.reduceRight((outlet, match) => {\r\n    Object.assign(params, match.params);\r\n    return /*#__PURE__*/createElement(RouteContext.Provider, {\r\n      children: match.route.element || /*#__PURE__*/createElement(Outlet, null),\r\n      value: {\r\n        outlet,\r\n        params: params,\r\n        pathname: joinPaths([basenameForMatching, match.pathname]),\r\n        basename,\r\n        route: match.route\r\n      }\r\n    });\r\n  }, null);\r\n  return element;\r\n} ///////////////////////////////////////////////////////////////////////////////\r\n// UTILS\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/**\r\n * Creates a route config from a React \"children\" object, which is usually\r\n * either a `<Route>` element or an array of them. Used internally by\r\n * `<Routes>` to create a route config from its children.\r\n *\r\n * @see https://reactrouter.com/api/createRoutesFromChildren\r\n */\r\n\r\nfunction createRoutesFromChildren(children) {\r\n  let routes = [];\r\n  Children.forEach(children, element => {\r\n    if (! /*#__PURE__*/isValidElement(element)) {\r\n      // Ignore non-elements. This allows people to more easily inline\r\n      // conditionals in their route config.\r\n      return;\r\n    }\r\n\r\n    if (element.type === Fragment) {\r\n      // Transparently support React.Fragment and its children.\r\n      routes.push.apply(routes, createRoutesFromChildren(element.props.children));\r\n      return;\r\n    }\r\n\r\n    let route = {\r\n      path: element.props.path,\r\n      caseSensitive: element.props.caseSensitive,\r\n      index: element.props.index,\r\n      element: element.props.element\r\n    };\r\n\r\n    if (element.props.children) {\r\n      route.children = createRoutesFromChildren(element.props.children);\r\n    }\r\n\r\n    routes.push(route);\r\n  });\r\n  return routes;\r\n}\r\n/**\r\n * Returns a path with params interpolated.\r\n *\r\n * @see https://reactrouter.com/api/generatePath\r\n */\r\n\r\nfunction generatePath(path, params) {\r\n  if (params === void 0) {\r\n    params = {};\r\n  }\r\n\r\n  return path.replace(/:(\\w+)/g, (_, key) => {\r\n    !(params[key] != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Missing \\\":\" + key + \"\\\" param\") : invariant(false) : void 0;\r\n    return params[key];\r\n  }).replace(/\\/*\\*$/, _ => params[\"*\"] == null ? \"\" : params[\"*\"].replace(/^\\/*/, \"/\"));\r\n}\r\n/**\r\n * Matches the given routes to a location and returns the match data.\r\n *\r\n * @see https://reactrouter.com/api/matchRoutes\r\n */\r\n\r\nfunction matchRoutes(routes, location, basename) {\r\n  if (basename === void 0) {\r\n    basename = \"\";\r\n  }\r\n\r\n  if (typeof location === \"string\") {\r\n    location = parsePath(location);\r\n  }\r\n\r\n  let pathname = location.pathname || \"/\";\r\n\r\n  if (basename) {\r\n    let base = basename.replace(/^\\/*/, \"/\").replace(/\\/+$/, \"\"); // Basename should be case-insensitive\r\n    // https://github.com/remix-run/react-router/issues/7997#issuecomment-911916907\r\n\r\n    if (!pathname.toLowerCase().startsWith(base.toLowerCase())) {\r\n      return null;\r\n    }\r\n\r\n    pathname = pathname.slice(base.length) || \"/\";\r\n  }\r\n\r\n  let branches = flattenRoutes(routes);\r\n  rankRouteBranches(branches);\r\n  let matches = null;\r\n\r\n  for (let i = 0; matches == null && i < branches.length; ++i) {\r\n    matches = matchRouteBranch(branches[i], pathname, routes);\r\n  }\r\n\r\n  return matches;\r\n}\r\n\r\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\r\n  if (branches === void 0) {\r\n    branches = [];\r\n  }\r\n\r\n  if (parentsMeta === void 0) {\r\n    parentsMeta = [];\r\n  }\r\n\r\n  if (parentPath === void 0) {\r\n    parentPath = \"\";\r\n  }\r\n\r\n  routes.forEach((route, index) => {\r\n    let meta = {\r\n      relativePath: route.path || \"\",\r\n      caseSensitive: route.caseSensitive === true,\r\n      childrenIndex: index\r\n    };\r\n\r\n    if (meta.relativePath.startsWith(\"/\")) {\r\n      !meta.relativePath.startsWith(parentPath) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Absolute route path \\\"\" + meta.relativePath + \"\\\" nested under path \" + (\"\\\"\" + parentPath + \"\\\" is not valid. An absolute child route path \") + \"must start with the combined path of all its parent routes.\") : invariant(false) : void 0;\r\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\r\n    }\r\n\r\n    let path = joinPaths([parentPath, meta.relativePath]);\r\n    let routesMeta = parentsMeta.concat(meta); // Add the children before adding this route to the array so we traverse the\r\n    // route tree depth-first and child routes appear before their parents in\r\n    // the \"flattened\" version.\r\n\r\n    if (route.children && route.children.length > 0) {\r\n      !(route.index !== true) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Index routes must not have child routes. Please remove \" + (\"all child routes from route path \\\"\" + path + \"\\\".\")) : invariant(false) : void 0;\r\n      flattenRoutes(route.children, branches, routesMeta, path);\r\n    }\r\n\r\n    branches.push({\r\n      path,\r\n      routesMeta\r\n    });\r\n  });\r\n  return branches;\r\n}\r\n\r\nfunction rankRouteBranches(branches) {\r\n  let pathScores = {};\r\n  let pathIndexes = {};\r\n  branches.forEach(_ref5 => {\r\n    let {\r\n      path,\r\n      routesMeta\r\n    } = _ref5;\r\n    pathScores[path] = computeScore(path);\r\n    pathIndexes[path] = routesMeta.map(meta => meta.childrenIndex);\r\n  });\r\n  branches.sort((a, b) => {\r\n    let aScore = pathScores[a.path];\r\n    let bScore = pathScores[b.path];\r\n    return aScore !== bScore ? bScore - aScore // Higher score first\r\n    : compareIndexes(pathIndexes[a.path], pathIndexes[b.path]);\r\n  });\r\n}\r\n\r\nconst paramRe = /^:\\w+$/;\r\nconst dynamicSegmentValue = 2;\r\nconst emptySegmentValue = 1;\r\nconst staticSegmentValue = 10;\r\nconst splatPenalty = -2;\r\n\r\nconst isSplat = s => s === \"*\";\r\n\r\nfunction computeScore(path) {\r\n  let segments = path.split(\"/\");\r\n  let initialScore = segments.length;\r\n\r\n  if (segments.some(isSplat)) {\r\n    initialScore += splatPenalty;\r\n  }\r\n\r\n  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\r\n}\r\n\r\nfunction compareIndexes(a, b) {\r\n  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\r\n  return siblings ? // If two routes are siblings, we should try to match the earlier sibling\r\n  // first. This allows people to have fine-grained control over the matching\r\n  // behavior by simply putting routes with identical paths in the order they\r\n  // want them tried.\r\n  a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,\r\n  // so they sort equally.\r\n  0;\r\n}\r\n\r\nfunction matchRouteBranch(branch, pathname, originalRoutes) {\r\n  let matchedPathname = \"/\";\r\n  let matchedParams = {};\r\n  let {\r\n    routesMeta\r\n  } = branch;\r\n  let routes = originalRoutes;\r\n  let matches = [];\r\n\r\n  for (let i = 0; i < routesMeta.length; ++i) {\r\n    let meta = routesMeta[i];\r\n    let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\r\n    let match = matchPath({\r\n      path: meta.relativePath,\r\n      caseSensitive: meta.caseSensitive,\r\n      end: i === routesMeta.length - 1\r\n    }, remainingPathname);\r\n    if (!match) return null;\r\n    matchedParams = _extends({}, matchedParams, match.params);\r\n    matchedPathname = joinPaths([matchedPathname, match.pathname]);\r\n    let route = routes[meta.childrenIndex];\r\n    matches.push({\r\n      params: matchedParams,\r\n      pathname: matchedPathname,\r\n      route\r\n    });\r\n    routes = route.children;\r\n  }\r\n\r\n  return matches;\r\n}\r\n/**\r\n * Performs pattern matching on a URL pathname and returns information about\r\n * the match.\r\n *\r\n * @see https://reactrouter.com/api/matchPath\r\n */\r\n\r\n\r\nfunction matchPath(pattern, pathname) {\r\n  if (typeof pattern === \"string\") {\r\n    pattern = {\r\n      path: pattern,\r\n      caseSensitive: false,\r\n      end: true\r\n    };\r\n  }\r\n\r\n  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\r\n  let match = pathname.match(matcher);\r\n  if (!match) return null;\r\n  let matchedPathname = match[1];\r\n  let values = match.slice(2);\r\n  let params = paramNames.reduce((memo, paramName, index) => {\r\n    memo[paramName] = safelyDecodeURIComponent(values[index] || \"\", paramName);\r\n    return memo;\r\n  }, {});\r\n  return {\r\n    params,\r\n    pathname: matchedPathname,\r\n    pattern\r\n  };\r\n}\r\n\r\nfunction compilePath(path, caseSensitive, end) {\r\n  if (caseSensitive === void 0) {\r\n    caseSensitive = false;\r\n  }\r\n\r\n  if (end === void 0) {\r\n    end = true;\r\n  }\r\n\r\n  let keys = [];\r\n  let source = \"^(\" + path.replace(/^\\/*/, \"/\") // Make sure it has a leading /\r\n  .replace(/\\/?\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\r\n  .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\r\n  .replace(/:(\\w+)/g, (_, key) => {\r\n    keys.push(key);\r\n    return \"([^\\\\/]+)\";\r\n  }) + \")\";\r\n\r\n  if (path.endsWith(\"*\")) {\r\n    if (path.endsWith(\"/*\")) {\r\n      source += \"(?:\\\\/(.+)|\\\\/?)\"; // Don't include the / in params['*']\r\n    } else {\r\n      source += \"(.*)\";\r\n    }\r\n\r\n    keys.push(\"*\");\r\n  } else if (end) {\r\n    source += \"\\\\/?\";\r\n  }\r\n\r\n  if (end) source += \"$\";\r\n  let flags = caseSensitive ? undefined : \"i\";\r\n  let matcher = new RegExp(source, flags);\r\n  return [matcher, keys];\r\n}\r\n\r\nfunction safelyDecodeURIComponent(value, paramName) {\r\n  try {\r\n    return decodeURIComponent(value);\r\n  } catch (error) {\r\n    process.env.NODE_ENV !== \"production\" ? warning(false, \"The value for the URL param \\\"\" + paramName + \"\\\" will not be decoded because\" + (\" the string \\\"\" + value + \"\\\" is a malformed URL segment. This is probably\") + (\" due to a bad percent encoding (\" + error + \").\")) : void 0;\r\n    return value;\r\n  }\r\n}\r\n/**\r\n * Returns a resolved path object relative to the given pathname.\r\n *\r\n * @see https://reactrouter.com/api/resolvePath\r\n */\r\n\r\n\r\nfunction resolvePath(to, fromPathname, basename) {\r\n  if (fromPathname === void 0) {\r\n    fromPathname = \"/\";\r\n  }\r\n\r\n  if (basename === void 0) {\r\n    basename = \"\";\r\n  }\r\n\r\n  let {\r\n    pathname: toPathname,\r\n    search = \"\",\r\n    hash = \"\"\r\n  } = typeof to === \"string\" ? parsePath(to) : to;\r\n  let pathname = toPathname ? resolvePathname(toPathname, toPathname.startsWith(\"/\") ? basename ? normalizeSlashes(\"/\" + basename) : \"/\" : fromPathname) : fromPathname;\r\n  return {\r\n    pathname,\r\n    search: normalizeSearch(search),\r\n    hash: normalizeHash(hash)\r\n  };\r\n}\r\n\r\nconst trimTrailingSlashes = path => path.replace(/\\/+$/, \"\");\r\n\r\nconst normalizeSlashes = path => path.replace(/\\/\\/+/g, \"/\");\r\n\r\nconst joinPaths = paths => normalizeSlashes(paths.join(\"/\"));\r\n\r\nconst splitPath = path => normalizeSlashes(path).split(\"/\");\r\n\r\nconst normalizeSearch = search => !search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\r\n\r\nconst normalizeHash = hash => !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\r\n\r\nfunction resolvePathname(toPathname, fromPathname) {\r\n  let segments = splitPath(trimTrailingSlashes(fromPathname));\r\n  let relativeSegments = splitPath(toPathname);\r\n  relativeSegments.forEach(segment => {\r\n    if (segment === \"..\") {\r\n      // Keep the root \"\" segment so the pathname starts at /\r\n      if (segments.length > 1) segments.pop();\r\n    } else if (segment !== \".\") {\r\n      segments.push(segment);\r\n    }\r\n  });\r\n  return segments.length > 1 ? joinPaths(segments) : \"/\";\r\n} ///////////////////////////////////////////////////////////////////////////////\r\n\r\nexport { MemoryRouter, Navigate, Outlet, Route, Router, Routes, LocationContext as UNSAFE_LocationContext, NavigatorContext as UNSAFE_NavigatorContext, RouteContext as UNSAFE_RouteContext, createRoutesFromChildren, generatePath, matchPath, matchRoutes, resolvePath, useBlocker, useHref, useInRouterContext, useLocation, useMatch, useNavigate, useOutlet, useParams, useResolvedPath, useRoutes };\r\n//# sourceMappingURL=index.js.map\r\n"]},"metadata":{},"sourceType":"module"}