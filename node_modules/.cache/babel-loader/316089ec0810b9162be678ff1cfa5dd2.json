{"ast":null,"code":"import { useRef, useState, useLayoutEffect, createElement, forwardRef, useCallback, useMemo } from 'react';\nimport { createBrowserHistory, createHashHistory, createPath } from 'history';\nimport { Router, useHref, useLocation, useResolvedPath, useNavigate, useBlocker } from 'react-router';\nexport { MemoryRouter, Navigate, Outlet, Route, Router, Routes, UNSAFE_LocationContext, UNSAFE_NavigatorContext, UNSAFE_RouteContext, createRoutesFromChildren, generatePath, matchPath, matchRoutes, resolvePath, useBlocker, useHref, useInRouterContext, useLocation, useMatch, useNavigate, useOutlet, useParams, useResolvedPath, useRoutes } from 'react-router';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nconst _excluded = [\"onClick\", \"replace\", \"state\", \"target\", \"to\"],\n      _excluded2 = [\"aria-current\", \"caseSensitive\", \"className\", \"end\", \"style\", \"to\"];\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message); // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * A <Router> for use in web browsers. Provides the cleanest URLs.\r\n */\n\n\nfunction BrowserRouter(_ref) {\n  let {\n    children,\n    window\n  } = _ref;\n  let historyRef = useRef();\n\n  if (historyRef.current == null) {\n    historyRef.current = createBrowserHistory({\n      window\n    });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = useState({\n    action: history.action,\n    location: history.location\n  });\n  useLayoutEffect(() => history.listen(setState), [history]);\n  return /*#__PURE__*/createElement(Router, {\n    children: children,\n    action: state.action,\n    location: state.location,\n    navigator: history\n  });\n}\n/**\r\n * A <Router> for use in web browsers. Stores the location in the hash\r\n * portion of the URL so it is not sent to the server.\r\n */\n\n\nfunction HashRouter(_ref2) {\n  let {\n    children,\n    window\n  } = _ref2;\n  let historyRef = useRef();\n\n  if (historyRef.current == null) {\n    historyRef.current = createHashHistory({\n      window\n    });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = useState({\n    action: history.action,\n    location: history.location\n  });\n  useLayoutEffect(() => history.listen(setState), [history]);\n  return /*#__PURE__*/createElement(Router, {\n    children: children,\n    action: state.action,\n    location: state.location,\n    navigator: history\n  });\n}\n\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\n/**\r\n * The public API for rendering a history-aware <a>.\r\n */\n\n\nconst Link = /*#__PURE__*/forwardRef(function LinkWithRef(_ref3, ref) {\n  let {\n    onClick,\n    replace = false,\n    state,\n    target,\n    to\n  } = _ref3,\n      rest = _objectWithoutPropertiesLoose(_ref3, _excluded);\n\n  let href = useHref(to);\n  let internalOnClick = useLinkClickHandler(to, {\n    replace,\n    state,\n    target\n  });\n\n  function handleClick(event) {\n    if (onClick) onClick(event);\n\n    if (!event.defaultPrevented) {\n      internalOnClick(event);\n    }\n  }\n\n  return (\n    /*#__PURE__*/\n    // eslint-disable-next-line jsx-a11y/anchor-has-content\n    createElement(\"a\", _extends({}, rest, {\n      href: href,\n      onClick: handleClick,\n      ref: ref,\n      target: target\n    }))\n  );\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  Link.displayName = \"Link\";\n}\n/**\r\n * A <Link> wrapper that knows if it's \"active\" or not.\r\n */\n\n\nconst NavLink = /*#__PURE__*/forwardRef(function NavLinkWithRef(_ref4, ref) {\n  let {\n    \"aria-current\": ariaCurrentProp = \"page\",\n    caseSensitive = false,\n    className: classNameProp = \"\",\n    end = false,\n    style: styleProp,\n    to\n  } = _ref4,\n      rest = _objectWithoutPropertiesLoose(_ref4, _excluded2);\n\n  let location = useLocation();\n  let path = useResolvedPath(to);\n  let locationPathname = location.pathname;\n  let toPathname = path.pathname;\n\n  if (!caseSensitive) {\n    locationPathname = locationPathname.toLowerCase();\n    toPathname = toPathname.toLowerCase();\n  }\n\n  let isActive = end ? locationPathname === toPathname : locationPathname.startsWith(toPathname);\n  let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n  let className;\n\n  if (typeof classNameProp === \"function\") {\n    className = classNameProp({\n      isActive\n    });\n  } else {\n    // If the className prop is not a function, we use a default `active`\n    // class for <NavLink />s that are active. In v5 `active` was the default\n    // value for `activeClassName`, but we are removing that API and can still\n    // use the old default behavior for a cleraner upgrade path and keep the\n    // simple styling rules working as the currently do.\n    className = [classNameProp, isActive ? \"active\" : null].filter(Boolean).join(\" \");\n  }\n\n  let style = typeof styleProp === \"function\" ? styleProp({\n    isActive\n  }) : styleProp;\n  return /*#__PURE__*/createElement(Link, _extends({}, rest, {\n    \"aria-current\": ariaCurrent,\n    className: className,\n    ref: ref,\n    style: style,\n    to: to\n  }));\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  NavLink.displayName = \"NavLink\";\n}\n/**\r\n * A declarative interface for showing a window.confirm dialog with the given\r\n * message when the user tries to navigate away from the current page.\r\n *\r\n * This also serves as a reference implementation for anyone who wants to\r\n * create their own custom prompt component.\r\n */\n\n\nfunction Prompt(_ref5) {\n  let {\n    message,\n    when\n  } = _ref5;\n  usePrompt(message, when);\n  return null;\n} ////////////////////////////////////////////////////////////////////////////////\n// HOOKS\n////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * Handles the click behavior for router `<Link>` components. This is useful if\r\n * you need to create custom `<Link>` compoments with the same click behavior we\r\n * use in our exported `<Link>`.\r\n */\n\n\nfunction useLinkClickHandler(to, _temp) {\n  let {\n    target,\n    replace: replaceProp,\n    state\n  } = _temp === void 0 ? {} : _temp;\n  let navigate = useNavigate();\n  let location = useLocation();\n  let path = useResolvedPath(to);\n  return useCallback(event => {\n    if (event.button === 0 && ( // Ignore everything but left clicks\n    !target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n    !isModifiedEvent(event) // Ignore clicks with modifier keys\n    ) {\n      event.preventDefault(); // If the URL hasn't changed, a regular <a> will do a replace instead of\n      // a push, so do the same here.\n\n      let replace = !!replaceProp || createPath(location) === createPath(path);\n      navigate(to, {\n        replace,\n        state\n      });\n    }\n  }, [location, navigate, path, replaceProp, state, target, to]);\n}\n/**\r\n * Prevents navigation away from the current page using a window.confirm prompt\r\n * with the given message.\r\n */\n\n\nfunction usePrompt(message, when) {\n  if (when === void 0) {\n    when = true;\n  }\n\n  let blocker = useCallback(tx => {\n    if (window.confirm(message)) tx.retry();\n  }, [message]);\n  useBlocker(blocker, when);\n}\n/**\r\n * A convenient wrapper for reading and writing search parameters via the\r\n * URLSearchParams interface.\r\n */\n\n\nfunction useSearchParams(defaultInit) {\n  process.env.NODE_ENV !== \"production\" ? warning(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not \" + \"support the URLSearchParams API. If you need to support Internet \" + \"Explorer 11, we recommend you load a polyfill such as \" + \"https://github.com/ungap/url-search-params\\n\\n\" + \"If you're unsure how to load polyfills, we recommend you check out \" + \"https://polyfill.io/v3/ which provides some recommendations about how \" + \"to load polyfills only for users that need them, instead of for every \" + \"user.\") : void 0;\n  let defaultSearchParamsRef = useRef(createSearchParams(defaultInit));\n  let location = useLocation();\n  let searchParams = useMemo(() => {\n    let searchParams = createSearchParams(location.search);\n\n    for (let key of defaultSearchParamsRef.current.keys()) {\n      if (!searchParams.has(key)) {\n        defaultSearchParamsRef.current.getAll(key).forEach(value => {\n          searchParams.append(key, value);\n        });\n      }\n    }\n\n    return searchParams;\n  }, [location.search]);\n  let navigate = useNavigate();\n  let setSearchParams = useCallback((nextInit, navigateOptions) => {\n    navigate(\"?\" + createSearchParams(nextInit), navigateOptions);\n  }, [navigate]);\n  return [searchParams, setSearchParams];\n}\n/**\r\n * Creates a URLSearchParams object using the given initializer.\r\n *\r\n * This is identical to `new URLSearchParams(init)` except it also\r\n * supports arrays as values in the object form of the initializer\r\n * instead of just strings. This is convenient when you need multiple\r\n * values for a given key, but don't want to use an array initializer.\r\n *\r\n * For example, instead of:\r\n *\r\n *   let searchParams = new URLSearchParams([\r\n *     ['sort', 'name'],\r\n *     ['sort', 'price']\r\n *   ]);\r\n *\r\n * you can do:\r\n *\r\n *   let searchParams = createSearchParams({\r\n *     sort: ['name', 'price']\r\n *   });\r\n */\n\n\nfunction createSearchParams(init) {\n  if (init === void 0) {\n    init = \"\";\n  }\n\n  return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {\n    let value = init[key];\n    return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);\n  }, []));\n}\n\nexport { BrowserRouter, HashRouter, Link, NavLink, Prompt, createSearchParams, useLinkClickHandler, usePrompt, useSearchParams };","map":{"version":3,"sources":["../../packages/react-router-dom/index.tsx"],"names":["React.useRef"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2FA,SAAA,OAAA,CAAA,IAAA,EAAA,OAAA,EAAA;;;;;;;;;;;;;AA6BG;;;;;;;;;;;;;mBA4JYA,MAAAA,E;;iBACF,O,IAAA,I,EAAA;;;;;;AAiBZ,MAAA,OAAA,GAAA,UAAA,CAAA,OAAA;;AAGC,IAAA,MAAA,EAAQ,OAAA,CAAA,M;;;;;;AAeJ,IAAA,MAAA,EAAA,KAAA,CAAA,M;YACM,EAAA,KAAO,CAAA,Q;aACN,EAAA;;;AAYb;;;;;;SAmBc,U,CAAA,K,EAAA;;AACV,IAAA,Q;AAA2C,IAAA;;;;;;;;;;;;YAUvC,OAAA,CAAA,M;YAGA,EAAA,OAAS,CAAA;;;;;AAWX,IAAA,MAAA,EAAA,KAAA,CAAA,M;;;;;;AAWN,SAAA,eAAA,CAAA,KAAA,EAAA;;;;;;;;;;;;;;;;MAqBkD,IAAA,GAAA,6BAAA,CAAA,KAAA,EAAA,SAAA,C;;;2CAKf,CAAA,EAAA,EAAK;AAAA,IAAA,OAAA;AAAA,IAAA,KAAA;;AAAA,GAAL,C;;;yBAKZ,K;;cACT,CAAC,gB,EAAA;AAET,MAAA,eAAA,CAAA,KAAA,CAAA;;;;AAWJ;AAAA;;;;;;;;AAAA","sourcesContent":["import { useRef, useState, useLayoutEffect, createElement, forwardRef, useCallback, useMemo } from 'react';\r\nimport { createBrowserHistory, createHashHistory, createPath } from 'history';\r\nimport { Router, useHref, useLocation, useResolvedPath, useNavigate, useBlocker } from 'react-router';\r\nexport { MemoryRouter, Navigate, Outlet, Route, Router, Routes, UNSAFE_LocationContext, UNSAFE_NavigatorContext, UNSAFE_RouteContext, createRoutesFromChildren, generatePath, matchPath, matchRoutes, resolvePath, useBlocker, useHref, useInRouterContext, useLocation, useMatch, useNavigate, useOutlet, useParams, useResolvedPath, useRoutes } from 'react-router';\r\n\r\nfunction _extends() {\r\n  _extends = Object.assign || function (target) {\r\n    for (var i = 1; i < arguments.length; i++) {\r\n      var source = arguments[i];\r\n\r\n      for (var key in source) {\r\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n          target[key] = source[key];\r\n        }\r\n      }\r\n    }\r\n\r\n    return target;\r\n  };\r\n\r\n  return _extends.apply(this, arguments);\r\n}\r\n\r\nfunction _objectWithoutPropertiesLoose(source, excluded) {\r\n  if (source == null) return {};\r\n  var target = {};\r\n  var sourceKeys = Object.keys(source);\r\n  var key, i;\r\n\r\n  for (i = 0; i < sourceKeys.length; i++) {\r\n    key = sourceKeys[i];\r\n    if (excluded.indexOf(key) >= 0) continue;\r\n    target[key] = source[key];\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\nconst _excluded = [\"onClick\", \"replace\", \"state\", \"target\", \"to\"],\r\n      _excluded2 = [\"aria-current\", \"caseSensitive\", \"className\", \"end\", \"style\", \"to\"];\r\n\r\nfunction warning(cond, message) {\r\n  if (!cond) {\r\n    // eslint-disable-next-line no-console\r\n    if (typeof console !== \"undefined\") console.warn(message);\r\n\r\n    try {\r\n      // Welcome to debugging React Router!\r\n      //\r\n      // This error is thrown as a convenience so you can more easily\r\n      // find the source for a warning that appears in the console by\r\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\r\n      throw new Error(message); // eslint-disable-next-line no-empty\r\n    } catch (e) {}\r\n  }\r\n} ////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * A <Router> for use in web browsers. Provides the cleanest URLs.\r\n */\r\n\r\nfunction BrowserRouter(_ref) {\r\n  let {\r\n    children,\r\n    window\r\n  } = _ref;\r\n  let historyRef = useRef();\r\n\r\n  if (historyRef.current == null) {\r\n    historyRef.current = createBrowserHistory({\r\n      window\r\n    });\r\n  }\r\n\r\n  let history = historyRef.current;\r\n  let [state, setState] = useState({\r\n    action: history.action,\r\n    location: history.location\r\n  });\r\n  useLayoutEffect(() => history.listen(setState), [history]);\r\n  return /*#__PURE__*/createElement(Router, {\r\n    children: children,\r\n    action: state.action,\r\n    location: state.location,\r\n    navigator: history\r\n  });\r\n}\r\n/**\r\n * A <Router> for use in web browsers. Stores the location in the hash\r\n * portion of the URL so it is not sent to the server.\r\n */\r\n\r\nfunction HashRouter(_ref2) {\r\n  let {\r\n    children,\r\n    window\r\n  } = _ref2;\r\n  let historyRef = useRef();\r\n\r\n  if (historyRef.current == null) {\r\n    historyRef.current = createHashHistory({\r\n      window\r\n    });\r\n  }\r\n\r\n  let history = historyRef.current;\r\n  let [state, setState] = useState({\r\n    action: history.action,\r\n    location: history.location\r\n  });\r\n  useLayoutEffect(() => history.listen(setState), [history]);\r\n  return /*#__PURE__*/createElement(Router, {\r\n    children: children,\r\n    action: state.action,\r\n    location: state.location,\r\n    navigator: history\r\n  });\r\n}\r\n\r\nfunction isModifiedEvent(event) {\r\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\r\n}\r\n/**\r\n * The public API for rendering a history-aware <a>.\r\n */\r\n\r\n\r\nconst Link = /*#__PURE__*/forwardRef(function LinkWithRef(_ref3, ref) {\r\n  let {\r\n    onClick,\r\n    replace = false,\r\n    state,\r\n    target,\r\n    to\r\n  } = _ref3,\r\n      rest = _objectWithoutPropertiesLoose(_ref3, _excluded);\r\n\r\n  let href = useHref(to);\r\n  let internalOnClick = useLinkClickHandler(to, {\r\n    replace,\r\n    state,\r\n    target\r\n  });\r\n\r\n  function handleClick(event) {\r\n    if (onClick) onClick(event);\r\n\r\n    if (!event.defaultPrevented) {\r\n      internalOnClick(event);\r\n    }\r\n  }\r\n\r\n  return (\r\n    /*#__PURE__*/\r\n    // eslint-disable-next-line jsx-a11y/anchor-has-content\r\n    createElement(\"a\", _extends({}, rest, {\r\n      href: href,\r\n      onClick: handleClick,\r\n      ref: ref,\r\n      target: target\r\n    }))\r\n  );\r\n});\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  Link.displayName = \"Link\";\r\n}\r\n/**\r\n * A <Link> wrapper that knows if it's \"active\" or not.\r\n */\r\n\r\n\r\nconst NavLink = /*#__PURE__*/forwardRef(function NavLinkWithRef(_ref4, ref) {\r\n  let {\r\n    \"aria-current\": ariaCurrentProp = \"page\",\r\n    caseSensitive = false,\r\n    className: classNameProp = \"\",\r\n    end = false,\r\n    style: styleProp,\r\n    to\r\n  } = _ref4,\r\n      rest = _objectWithoutPropertiesLoose(_ref4, _excluded2);\r\n\r\n  let location = useLocation();\r\n  let path = useResolvedPath(to);\r\n  let locationPathname = location.pathname;\r\n  let toPathname = path.pathname;\r\n\r\n  if (!caseSensitive) {\r\n    locationPathname = locationPathname.toLowerCase();\r\n    toPathname = toPathname.toLowerCase();\r\n  }\r\n\r\n  let isActive = end ? locationPathname === toPathname : locationPathname.startsWith(toPathname);\r\n  let ariaCurrent = isActive ? ariaCurrentProp : undefined;\r\n  let className;\r\n\r\n  if (typeof classNameProp === \"function\") {\r\n    className = classNameProp({\r\n      isActive\r\n    });\r\n  } else {\r\n    // If the className prop is not a function, we use a default `active`\r\n    // class for <NavLink />s that are active. In v5 `active` was the default\r\n    // value for `activeClassName`, but we are removing that API and can still\r\n    // use the old default behavior for a cleraner upgrade path and keep the\r\n    // simple styling rules working as the currently do.\r\n    className = [classNameProp, isActive ? \"active\" : null].filter(Boolean).join(\" \");\r\n  }\r\n\r\n  let style = typeof styleProp === \"function\" ? styleProp({\r\n    isActive\r\n  }) : styleProp;\r\n  return /*#__PURE__*/createElement(Link, _extends({}, rest, {\r\n    \"aria-current\": ariaCurrent,\r\n    className: className,\r\n    ref: ref,\r\n    style: style,\r\n    to: to\r\n  }));\r\n});\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  NavLink.displayName = \"NavLink\";\r\n}\r\n/**\r\n * A declarative interface for showing a window.confirm dialog with the given\r\n * message when the user tries to navigate away from the current page.\r\n *\r\n * This also serves as a reference implementation for anyone who wants to\r\n * create their own custom prompt component.\r\n */\r\n\r\n\r\nfunction Prompt(_ref5) {\r\n  let {\r\n    message,\r\n    when\r\n  } = _ref5;\r\n  usePrompt(message, when);\r\n  return null;\r\n} ////////////////////////////////////////////////////////////////////////////////\r\n// HOOKS\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n/**\r\n * Handles the click behavior for router `<Link>` components. This is useful if\r\n * you need to create custom `<Link>` compoments with the same click behavior we\r\n * use in our exported `<Link>`.\r\n */\r\n\r\nfunction useLinkClickHandler(to, _temp) {\r\n  let {\r\n    target,\r\n    replace: replaceProp,\r\n    state\r\n  } = _temp === void 0 ? {} : _temp;\r\n  let navigate = useNavigate();\r\n  let location = useLocation();\r\n  let path = useResolvedPath(to);\r\n  return useCallback(event => {\r\n    if (event.button === 0 && ( // Ignore everything but left clicks\r\n    !target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\r\n    !isModifiedEvent(event) // Ignore clicks with modifier keys\r\n    ) {\r\n        event.preventDefault(); // If the URL hasn't changed, a regular <a> will do a replace instead of\r\n        // a push, so do the same here.\r\n\r\n        let replace = !!replaceProp || createPath(location) === createPath(path);\r\n        navigate(to, {\r\n          replace,\r\n          state\r\n        });\r\n      }\r\n  }, [location, navigate, path, replaceProp, state, target, to]);\r\n}\r\n/**\r\n * Prevents navigation away from the current page using a window.confirm prompt\r\n * with the given message.\r\n */\r\n\r\nfunction usePrompt(message, when) {\r\n  if (when === void 0) {\r\n    when = true;\r\n  }\r\n\r\n  let blocker = useCallback(tx => {\r\n    if (window.confirm(message)) tx.retry();\r\n  }, [message]);\r\n  useBlocker(blocker, when);\r\n}\r\n/**\r\n * A convenient wrapper for reading and writing search parameters via the\r\n * URLSearchParams interface.\r\n */\r\n\r\nfunction useSearchParams(defaultInit) {\r\n  process.env.NODE_ENV !== \"production\" ? warning(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not \" + \"support the URLSearchParams API. If you need to support Internet \" + \"Explorer 11, we recommend you load a polyfill such as \" + \"https://github.com/ungap/url-search-params\\n\\n\" + \"If you're unsure how to load polyfills, we recommend you check out \" + \"https://polyfill.io/v3/ which provides some recommendations about how \" + \"to load polyfills only for users that need them, instead of for every \" + \"user.\") : void 0;\r\n  let defaultSearchParamsRef = useRef(createSearchParams(defaultInit));\r\n  let location = useLocation();\r\n  let searchParams = useMemo(() => {\r\n    let searchParams = createSearchParams(location.search);\r\n\r\n    for (let key of defaultSearchParamsRef.current.keys()) {\r\n      if (!searchParams.has(key)) {\r\n        defaultSearchParamsRef.current.getAll(key).forEach(value => {\r\n          searchParams.append(key, value);\r\n        });\r\n      }\r\n    }\r\n\r\n    return searchParams;\r\n  }, [location.search]);\r\n  let navigate = useNavigate();\r\n  let setSearchParams = useCallback((nextInit, navigateOptions) => {\r\n    navigate(\"?\" + createSearchParams(nextInit), navigateOptions);\r\n  }, [navigate]);\r\n  return [searchParams, setSearchParams];\r\n}\r\n/**\r\n * Creates a URLSearchParams object using the given initializer.\r\n *\r\n * This is identical to `new URLSearchParams(init)` except it also\r\n * supports arrays as values in the object form of the initializer\r\n * instead of just strings. This is convenient when you need multiple\r\n * values for a given key, but don't want to use an array initializer.\r\n *\r\n * For example, instead of:\r\n *\r\n *   let searchParams = new URLSearchParams([\r\n *     ['sort', 'name'],\r\n *     ['sort', 'price']\r\n *   ]);\r\n *\r\n * you can do:\r\n *\r\n *   let searchParams = createSearchParams({\r\n *     sort: ['name', 'price']\r\n *   });\r\n */\r\n\r\nfunction createSearchParams(init) {\r\n  if (init === void 0) {\r\n    init = \"\";\r\n  }\r\n\r\n  return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {\r\n    let value = init[key];\r\n    return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);\r\n  }, []));\r\n}\r\n\r\nexport { BrowserRouter, HashRouter, Link, NavLink, Prompt, createSearchParams, useLinkClickHandler, usePrompt, useSearchParams };\r\n//# sourceMappingURL=index.js.map\r\n"]},"metadata":{},"sourceType":"module"}